<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAC4 Integration Modeller - Visual Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --purple: #8b5cf6;
            --bg-main: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-dark: #1e293b;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --border: #e2e8f0;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-secondary);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: white;
            color: var(--purple);
        }

        .btn-primary:hover:not(:disabled) {
            background: #f3f4f6;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e5e7eb;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
        }

        .btn-icon {
            padding: 0.5rem;
            min-width: 2.5rem;
            justify-content: center;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: white;
            border-bottom: 1px solid var(--border);
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 0.25rem;
            padding: 0 0.5rem;
            border-right: 1px solid var(--border);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr 380px;
            height: calc(100vh - 120px);
            gap: 0;
        }

        /* Left Panel - Component Palette */
        .palette {
            background: white;
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 1.5rem;
        }

        .palette h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: 0.05em;
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .palette-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .palette-item:hover {
            border-color: var(--purple);
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-icon {
            font-size: 1.5rem;
            min-width: 2rem;
            text-align: center;
        }

        .palette-label {
            flex: 1;
        }

        .palette-label-title {
            font-weight: 600;
            font-size: 0.875rem;
        }

        .palette-label-desc {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Palette Search & Organization */
        .palette-search {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }

        .palette-search input {
            width: 100%;
            padding: 0.5rem 2rem 0.5rem 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }

        .palette-search input:focus {
            outline: none;
            border-color: var(--purple);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .palette-search button {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: var(--text-secondary);
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .collapse-icon {
            transition: transform 0.2s;
            display: inline-block;
        }

        .collapsible.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .favorite-btn {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            background: white;
            border: 1px solid var(--border);
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            z-index: 5;
            font-size: 0.875rem;
        }

        .palette-item:hover .favorite-btn {
            opacity: 1;
        }

        .favorite-btn.active {
            opacity: 1;
            background: var(--purple);
            color: white;
            border-color: var(--purple);
        }

        .palette-item.search-hidden {
            display: none;
        }

        .palette-item.search-match {
            background: rgba(139, 92, 246, 0.1);
            border-color: var(--purple);
        }

        /* Multi-Select */
        .node.selected {
            border-color: var(--purple);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
        }

        .node.multi-selected {
            border-color: var(--purple);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }

        .selection-box {
            position: absolute;
            border: 2px dashed var(--purple);
            background: rgba(139, 92, 246, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        .selection-badge {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--purple);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            animation: slideInUp 0.3s ease-out;
            z-index: 1001;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Grid */
        .canvas.show-grid .canvas-inner {
            background-image:
                linear-gradient(to right, rgba(139, 92, 246, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(139, 92, 246, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Alignment Guides */
        .alignment-guide {
            position: absolute;
            background: #f59e0b;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .alignment-guide.visible {
            opacity: 1;
        }

        .alignment-guide.vertical {
            width: 2px;
            height: 100%;
            top: 0;
        }

        .alignment-guide.horizontal {
            height: 2px;
            width: 100%;
            left: 0;
        }

        #gridToggle.active,
        #snapToggle.active,
        #guidesToggle.active {
            background: var(--purple);
            color: white;
        }

        /* Mini-Map */
        .mini-map {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 200px;
            height: 150px;
            background: white;
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .mini-map.hidden {
            display: none;
        }

        .mini-map-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.25rem 0.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            font-weight: 600;
        }

        .mini-map-canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-secondary);
        }

        .mini-map-node {
            position: absolute;
            border-radius: 2px;
            border: 1px solid;
        }

        .mini-map-node.system {
            background: rgba(59, 130, 246, 0.7);
            border-color: #3b82f6;
        }

        .mini-map-node.integration {
            background: rgba(139, 92, 246, 0.7);
            border-color: #8b5cf6;
        }

        .mini-map-viewport {
            position: absolute;
            border: 2px solid var(--purple);
            background: rgba(139, 92, 246, 0.1);
            cursor: move;
        }

        /* Keyboard Shortcuts */
        .shortcuts-table {
            width: 100%;
            font-size: 0.875rem;
        }

        .shortcuts-table td {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcuts-table td:first-child {
            font-weight: 600;
            color: var(--text-secondary);
            width: 140px;
        }

        kbd {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        /* Canvas */
        .canvas-container {
            position: relative;
            background: #f9fafb;
            overflow: hidden;
        }

        .canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(139, 92, 246, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(139, 92, 246, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
        }

        .canvas.grabbing {
            cursor: grabbing;
        }

        .canvas-inner {
            position: relative;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        /* System Node */
        .system-node {
            position: absolute;
            background: white;
            border: 3px solid var(--primary);
            border-radius: 0.75rem;
            padding: 1rem;
            min-width: 160px;
            cursor: move;
            box-shadow: 0 4px 6px var(--shadow);
            transition: all 0.2s;
            user-select: none;
        }

        .system-node:hover {
            box-shadow: 0 8px 16px rgba(37, 99, 235, 0.3);
            transform: scale(1.02);
        }

        .system-node.selected {
            border-color: var(--purple);
            border-width: 4px;
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.5);
        }

        .system-node.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }

        .node-icon {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .node-title {
            font-weight: 700;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
            word-wrap: break-word;
        }

        .node-subtitle {
            font-size: 0.7rem;
            text-align: center;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }

        /* Connection Points - React Flow Style */
        .connection-point {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #8b5cf6;
            border: 3px solid white;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
            transition: all 0.15s;
            box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
        }

        .connection-point:hover {
            width: 18px;
            height: 18px;
            background: #7c3aed;
            box-shadow: 0 0 0 6px rgba(139, 92, 246, 0.3);
            transform: scale(1.1);
        }

        .connection-point.connecting {
            background: #10b981;
            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.3);
            animation: pulse 0.6s ease-in-out infinite;
        }

        .connection-point.snap-target {
            background: #10b981;
            width: 20px;
            height: 20px;
            box-shadow: 0 0 0 8px rgba(16, 185, 129, 0.5);
            border-color: #fff;
            border-width: 4px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Four connection points per node - React Flow style */
        .connection-point.top {
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.right {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.bottom {
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.left {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.top:hover,
        .connection-point.bottom:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .connection-point.left:hover,
        .connection-point.right:hover {
            transform: translateY(-50%) scale(1.1);
        }

        /* Integration Node */
        .integration-node {
            position: absolute;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: 3px solid #6d28d9;
            border-radius: 0.75rem;
            padding: 1rem;
            min-width: 180px;
            cursor: move;
            box-shadow: 0 4px 6px rgba(0,0,0,0.15);
            user-select: none;
        }

        .integration-node:hover {
            box-shadow: 0 8px 16px rgba(139, 92, 246, 0.5);
            transform: scale(1.02);
        }

        .integration-node.selected {
            border-color: #fbbf24;
            border-width: 4px;
            box-shadow: 0 8px 20px rgba(251, 191, 36, 0.5);
        }

        .integration-node.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }

        .integration-icon {
            font-size: 2rem;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .integration-title {
            font-weight: 700;
            font-size: 0.9rem;
            text-align: center;
            margin-bottom: 0.25rem;
            word-wrap: break-word;
        }

        .integration-pattern {
            font-size: 0.65rem;
            text-align: center;
            background: rgba(255,255,255,0.25);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            text-transform: uppercase;
            font-weight: 700;
        }

        /* Connection Lines */
        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            transform-origin: 0 0;
            overflow: visible;
        }

        .connection-line {
            stroke: var(--purple);
            stroke-width: 3;
            fill: none;
            marker-end: url(#arrowhead);
            opacity: 0.8;
            transition: all 0.2s;
        }

        .connection-line:hover {
            stroke-width: 4;
            opacity: 1;
        }

        .connection-line.creating {
            stroke-dasharray: 5, 5;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        .connection-label {
            fill: var(--text-primary);
            font-size: 0.7rem;
            font-weight: 600;
            background: white;
            padding: 2px 4px;
        }

        .connection-label-bg {
            fill: white;
            opacity: 0.9;
        }

        /* Right Panel - Properties */
        .properties-panel {
            background: white;
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 1.5rem;
        }

        .properties-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .properties-header h3 {
            font-size: 1.125rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-section {
            margin-bottom: 1.5rem;
        }

        .form-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border);
            letter-spacing: 0.05em;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.375rem;
            color: var(--text-primary);
        }

        .form-group label .required {
            color: var(--danger);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.625rem;
            border: 2px solid var(--border);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--purple);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .form-group textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            resize: vertical;
        }

        .form-help {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 0.875rem;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow);
            padding: 0.5rem;
            z-index: 50;
        }

        .zoom-level {
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 0.25rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .modal-header h2 {
            font-size: 1.5rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-btn:hover {
            color: var(--text-primary);
            background: var(--bg-secondary);
            border-radius: 0.25rem;
        }

        .template-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        .template-card {
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .template-card:hover {
            border-color: var(--purple);
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .template-title {
            font-weight: 700;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .template-desc {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            border-left: 4px solid;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: #d1fae5;
            border-color: var(--success);
            color: #065f46;
        }

        .alert-error {
            background: #fee2e2;
            border-color: var(--danger);
            color: #991b1b;
        }

        .alert-info {
            background: #dbeafe;
            border-color: var(--primary);
            color: #1e40af;
        }

        input[type="file"] {
            display: none;
        }

        .quick-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow);
            padding: 0.5rem 0;
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
        }

        .context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .context-menu-separator {
            height: 1px;
            background: var(--border);
            margin: 0.5rem 0;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-dark);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 2000;
            display: none;
            white-space: nowrap;
        }

        .tooltip.active {
            display: block;
        }

        /* Help Overlay */
        .help-overlay {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px var(--shadow);
            padding: 1rem;
            max-width: 300px;
            z-index: 100;
            display: none;
        }

        .help-overlay.active {
            display: block;
        }

        .help-title {
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .help-item {
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            gap: 1rem;
        }

        .help-key {
            font-family: monospace;
            background: var(--bg-secondary);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            .palette, .properties-panel {
                display: none;
            }
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>üé® BAC4 Integration Modeller</h1>
        <div class="header-actions">
            <button class="btn btn-primary" onclick="openTemplates()" title="Load a template">üìë Templates</button>
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" title="Load JSON file">üìÅ Load</button>
            <button class="btn btn-success" onclick="exportJSON()" title="Export to JSON">üíæ Export</button>
            <button class="btn btn-secondary" onclick="toggleHelp()" title="Show keyboard shortcuts">‚ùì Help</button>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-group">
            <button class="btn btn-secondary btn-icon" onclick="undo()" id="undoBtn" disabled title="Undo (Ctrl+Z)">‚Ü∂</button>
            <button class="btn btn-secondary btn-icon" onclick="redo()" id="redoBtn" disabled title="Redo (Ctrl+Y)">‚Ü∑</button>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-secondary" onclick="newIntegration()" title="Create new integration">+ New Integration</button>
            <button class="btn btn-secondary" onclick="showValidationResults()" title="Validate design">üîç Validate</button>
            <span id="validationIndicator" style="margin-left: 0.5rem; padding: 0.25rem 0.75rem; background: #f3f4f6; border-radius: 0.25rem; font-size: 0.875rem; font-weight: 600; cursor: pointer;" onclick="showValidationResults()" title="Click to see validation details">‚úÖ Valid</span>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-secondary" onclick="selectAll()" title="Select all (Ctrl+A)">Select All</button>
            <button class="btn btn-secondary" id="bulkActions" onclick="showBulkActionsMenu()" style="display: none;" title="Bulk actions">Actions ‚ñº</button>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-secondary btn-icon" onclick="toggleGrid()" id="gridToggle" title="Toggle grid (Ctrl+G)">#Ô∏è‚É£</button>
            <button class="btn btn-secondary btn-icon" onclick="toggleSnapToGrid()" id="snapToggle" title="Snap to grid">üß≤</button>
            <button class="btn btn-secondary btn-icon" onclick="toggleAlignmentGuides()" id="guidesToggle" title="Alignment guides">üìè</button>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-secondary" onclick="autoLayout()" title="Auto-arrange nodes">üìê Auto Layout</button>
            <button class="btn btn-secondary" onclick="fitToView()" title="Fit to view">üîç Fit View</button>
            <button class="btn btn-secondary" onclick="exportAsPNG()" title="Export as image">üñºÔ∏è Export PNG</button>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-danger" onclick="clearAll()" title="Clear canvas">üóëÔ∏è Clear All</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Panel: Component Palette -->
        <div class="palette">
            <!-- Search Bar -->
            <div class="palette-search">
                <input type="text" id="paletteSearch" placeholder="üîç Search components..." oninput="filterPalette(this.value)">
                <button onclick="clearPaletteSearch()">‚úï</button>
            </div>

            <div class="section">
                <h3>üöÄ Quick Start</h3>
                <div class="quick-actions">
                    <button class="btn btn-secondary" style="width: 100%;" onclick="loadExample('rest-api')">REST API Example</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="loadExample('kafka')">Kafka Example</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="loadExample('file-transfer')">File Transfer</button>
                </div>
            </div>

            <div class="section">
                <h3 class="collapsible" onclick="toggleSection('systems')">
                    <span class="collapse-icon">‚ñº</span> üñ•Ô∏è Systems (20)
                </h3>
                <div id="systemsContent">
                <div class="palette-item" draggable="true" data-type="system" data-subtype="application" data-search-terms="application business app software">
                    <span class="palette-icon">üíº</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Application</div>
                        <div class="palette-label-desc">Business app</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="database">
                    <span class="palette-icon">üóÑÔ∏è</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Database</div>
                        <div class="palette-label-desc">Data storage</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="service">
                    <span class="palette-icon">‚òÅÔ∏è</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Service</div>
                        <div class="palette-label-desc">Cloud service</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="external">
                    <span class="palette-icon">üåê</span>
                    <div class="palette-label">
                        <div class="palette-label-title">External</div>
                        <div class="palette-label-desc">3rd party</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="legacy">
                    <span class="palette-icon">üñ•Ô∏è</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Legacy</div>
                        <div class="palette-label-desc">Legacy system</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="api-gateway">
                    <span class="palette-icon">üö™</span>
                    <div class="palette-label">
                        <div class="palette-label-title">API Gateway</div>
                        <div class="palette-label-desc">API routing</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="message-broker">
                    <span class="palette-icon">üìÆ</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Message Broker</div>
                        <div class="palette-label-desc">Kafka, RabbitMQ</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="cache">
                    <span class="palette-icon">‚ö°</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Cache</div>
                        <div class="palette-label-desc">Redis, Memcached</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="file-storage">
                    <span class="palette-icon">üì¶</span>
                    <div class="palette-label">
                        <div class="palette-label-title">File Storage</div>
                        <div class="palette-label-desc">S3, Azure Blob</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="data-warehouse">
                    <span class="palette-icon">üè¢</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Data Warehouse</div>
                        <div class="palette-label-desc">Snowflake, BigQuery</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="etl">
                    <span class="palette-icon">üîÄ</span>
                    <div class="palette-label">
                        <div class="palette-label-title">ETL Tool</div>
                        <div class="palette-label-desc">Transform data</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="container">
                    <span class="palette-icon">üê≥</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Container</div>
                        <div class="palette-label-desc">Docker, K8s</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="serverless">
                    <span class="palette-icon">‚öôÔ∏è</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Serverless</div>
                        <div class="palette-label-desc">Lambda, Functions</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="auth">
                    <span class="palette-icon">üîê</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Auth Service</div>
                        <div class="palette-label-desc">OAuth, SAML</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="monitoring">
                    <span class="palette-icon">üìä</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Monitoring</div>
                        <div class="palette-label-desc">Observability</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="cdn">
                    <span class="palette-icon">üåç</span>
                    <div class="palette-label">
                        <div class="palette-label-title">CDN</div>
                        <div class="palette-label-desc">Content delivery</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="analytics">
                    <span class="palette-icon">üìà</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Analytics</div>
                        <div class="palette-label-desc">BI, reporting</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="crm">
                    <span class="palette-icon">üë•</span>
                    <div class="palette-label">
                        <div class="palette-label-title">CRM</div>
                        <div class="palette-label-desc">Salesforce, Dynamics</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="erp">
                    <span class="palette-icon">üè≠</span>
                    <div class="palette-label">
                        <div class="palette-label-title">ERP</div>
                        <div class="palette-label-desc">SAP, Oracle</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="system" data-subtype="hr">
                    <span class="palette-icon">üëî</span>
                    <div class="palette-label">
                        <div class="palette-label-title">HR System</div>
                        <div class="palette-label-desc">Workday, ADP</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="section">
                <h3 class="collapsible" onclick="toggleSection('patterns')">
                    <span class="collapse-icon">‚ñº</span> üîå Integration Patterns (13)
                </h3>
                <div id="patternsContent">
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="rest-api" data-search-terms="rest api http https web service">
                    <span class="palette-icon">üîå</span>
                    <div class="palette-label">
                        <div class="palette-label-title">REST API</div>
                        <div class="palette-label-desc">HTTP/HTTPS</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="soap-api">
                    <span class="palette-icon">üßº</span>
                    <div class="palette-label">
                        <div class="palette-label-title">SOAP API</div>
                        <div class="palette-label-desc">WSDL, XML</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="graphql">
                    <span class="palette-icon">üìä</span>
                    <div class="palette-label">
                        <div class="palette-label-title">GraphQL</div>
                        <div class="palette-label-desc">Query API</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="grpc">
                    <span class="palette-icon">‚ö°</span>
                    <div class="palette-label">
                        <div class="palette-label-title">gRPC</div>
                        <div class="palette-label-desc">RPC, Protobuf</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="websocket">
                    <span class="palette-icon">üîó</span>
                    <div class="palette-label">
                        <div class="palette-label-title">WebSocket</div>
                        <div class="palette-label-desc">Real-time</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="event-stream">
                    <span class="palette-icon">üì®</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Event Stream</div>
                        <div class="palette-label-desc">Kafka, Kinesis</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="messaging">
                    <span class="palette-icon">üí¨</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Messaging</div>
                        <div class="palette-label-desc">Queue, MQ</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="file-transfer">
                    <span class="palette-icon">üìÅ</span>
                    <div class="palette-label">
                        <div class="palette-label-title">File Transfer</div>
                        <div class="palette-label-desc">FTP, SFTP</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="batch">
                    <span class="palette-icon">üì¶</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Batch</div>
                        <div class="palette-label-desc">Scheduled</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="database-sync">
                    <span class="palette-icon">üîÑ</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Database Sync</div>
                        <div class="palette-label-desc">CDC, Replication</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="edi">
                    <span class="palette-icon">üìã</span>
                    <div class="palette-label">
                        <div class="palette-label-title">EDI</div>
                        <div class="palette-label-desc">X12, EDIFACT</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="webhook">
                    <span class="palette-icon">ü™ù</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Webhook</div>
                        <div class="palette-label-desc">Event callback</div>
                    </div>
                </div>
                <div class="palette-item" draggable="true" data-type="integration" data-pattern="custom">
                    <span class="palette-icon">üîß</span>
                    <div class="palette-label">
                        <div class="palette-label-title">Custom</div>
                        <div class="palette-label-desc">Custom logic</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="section">
                <h3>üí° Tips</h3>
                <p style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.4;">
                    ‚Ä¢ Drag items onto canvas<br>
                    ‚Ä¢ <strong>4 connection points</strong> per node (top/right/bottom/left)<br>
                    ‚Ä¢ Click & drag from any purple dot to connect<br>
                    ‚Ä¢ Right-click for context menu<br>
                    ‚Ä¢ Mouse wheel to zoom<br>
                    ‚Ä¢ Press <strong>?</strong> for shortcuts
                </p>
            </div>
        </div>

        <!-- Center: Canvas -->
        <div class="canvas-container">
            <div class="canvas" id="canvas">
                <svg class="connections-layer" id="connectionsSvg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="#8b5cf6" />
                        </marker>
                    </defs>
                </svg>
                <div class="canvas-inner" id="canvasInner">
                    <div class="empty-state">
                        <div class="empty-state-icon">üé®</div>
                        <h3>Start Building Your Integration</h3>
                        <p>Drag systems and integration patterns from the left panel</p>
                        <p style="margin-top: 0.5rem;"><strong>Create Edges:</strong> Click & drag from any purple connection point</p>
                        <p style="margin-top: 0.25rem;">Each node has 4 connection points (‚¨ÜÔ∏è‚û°Ô∏è‚¨áÔ∏è‚¨ÖÔ∏è)</p>
                        <p style="margin-top: 0.5rem;">Or load an example to get started quickly</p>
                    </div>
                </div>
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button class="btn btn-secondary btn-icon" onclick="zoomIn()" title="Zoom in">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="btn btn-secondary btn-icon" onclick="zoomOut()" title="Zoom out">‚àí</button>
                <button class="btn btn-secondary btn-icon" onclick="resetZoom()" title="Reset zoom">‚äô</button>
            </div>
        </div>

        <!-- Right Panel: Properties -->
        <div class="properties-panel" id="propertiesPanel">
            <div class="empty-state">
                <div class="empty-state-icon">‚öôÔ∏è</div>
                <h3>Properties</h3>
                <p>Select a component to edit its properties</p>
                <p style="margin-top: 1rem; font-size: 0.75rem;">üí° <strong>Tip:</strong> Click & drag from purple connection points (each node has 4: ‚¨ÜÔ∏è‚û°Ô∏è‚¨áÔ∏è‚¨ÖÔ∏è)</p>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="contextAction('edit')">‚úèÔ∏è Edit Properties</div>
        <div class="context-menu-item" onclick="contextAction('duplicate')">üìã Duplicate</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="contextAction('delete')">üóëÔ∏è Delete</div>
    </div>

    <!-- Help Overlay -->
    <div class="help-overlay" id="helpOverlay">
        <div class="help-title">
            <span>‚å®Ô∏è Keyboard Shortcuts</span>
            <button class="close-btn" onclick="toggleHelp()" style="width: 1.5rem; height: 1.5rem; font-size: 1rem;">√ó</button>
        </div>
        <div class="help-item">
            <span>Undo</span>
            <span class="help-key">Ctrl+Z</span>
        </div>
        <div class="help-item">
            <span>Redo</span>
            <span class="help-key">Ctrl+Y</span>
        </div>
        <div class="help-item">
            <span>Delete selected</span>
            <span class="help-key">Del</span>
        </div>
        <div class="help-item">
            <span>Select all</span>
            <span class="help-key">Ctrl+A</span>
        </div>
        <div class="help-item">
            <span>Save/Export</span>
            <span class="help-key">Ctrl+S</span>
        </div>
        <div class="help-item">
            <span>Zoom in</span>
            <span class="help-key">Wheel ‚Üë</span>
        </div>
        <div class="help-item">
            <span>Zoom out</span>
            <span class="help-key">Wheel ‚Üì</span>
        </div>
        <div class="help-item">
            <span>Pan canvas</span>
            <span class="help-key">Drag</span>
        </div>
    </div>

    <!-- Template Modal -->
    <div class="modal" id="templateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìë Integration Templates</h2>
                <button class="close-btn" onclick="closeModal('templateModal')">√ó</button>
            </div>
            <div class="template-grid">
                <div class="template-card" onclick="loadTemplate('rest-api')">
                    <div class="template-title">üîå REST API Integration</div>
                    <div class="template-desc">Synchronous request-response pattern for real-time data exchange between systems using HTTP/HTTPS</div>
                </div>
                <div class="template-card" onclick="loadTemplate('event-stream')">
                    <div class="template-title">üì® Event Streaming</div>
                    <div class="template-desc">Kafka-based event streaming for real-time, scalable data pipelines with high throughput</div>
                </div>
                <div class="template-card" onclick="loadTemplate('file-transfer')">
                    <div class="template-title">üìÅ File Transfer</div>
                    <div class="template-desc">Batch file transfer with SFTP for scheduled data exchange and large file processing</div>
                </div>
                <div class="template-card" onclick="loadTemplate('messaging')">
                    <div class="template-title">üí¨ Message Queue</div>
                    <div class="template-desc">Asynchronous messaging with queues for reliable, decoupled system communication</div>
                </div>
                <div class="template-card" onclick="loadTemplate('database-sync')">
                    <div class="template-title">üîÑ Database Sync</div>
                    <div class="template-desc">Change data capture for real-time database synchronization and replication</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".json" onchange="loadJSONFile(event)">

    <!-- Bulk Actions Menu -->
    <div id="bulkActionsMenu" class="context-menu" style="display: none;">
        <div class="context-menu-item" onclick="bulkAlign('left')">‚¨ÖÔ∏è Align Left</div>
        <div class="context-menu-item" onclick="bulkAlign('right')">‚û°Ô∏è Align Right</div>
        <div class="context-menu-item" onclick="bulkAlign('top')">‚¨ÜÔ∏è Align Top</div>
        <div class="context-menu-item" onclick="bulkAlign('bottom')">‚¨áÔ∏è Align Bottom</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="bulkDistribute('horizontal')">‚ÜîÔ∏è Distribute Horizontal</div>
        <div class="context-menu-item" onclick="bulkDistribute('vertical')">‚ÜïÔ∏è Distribute Vertical</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="bulkDuplicate()">üìã Duplicate</div>
        <div class="context-menu-item" onclick="bulkDelete()" style="color: #ef4444;">üóëÔ∏è Delete All</div>
    </div>

    <!-- Mini-Map -->
    <div class="mini-map" id="miniMap">
        <div class="mini-map-header">
            <span>Map</span>
            <button onclick="toggleMiniMap()" style="background: none; border: none; cursor: pointer; font-size: 0.75rem;">‚äô</button>
        </div>
        <div class="mini-map-canvas" id="miniMapCanvas"></div>
        <div class="mini-map-viewport" id="miniMapViewport"></div>
    </div>

    <script>
        // ============ Global State ============
        let integrationData = {
            version: "1.0.0",
            info: {
                title: "New Integration",
                version: "1.0.0",
                description: "",
                tags: []
            },
            systems: {},
            integrations: [],
            components: {
                schemas: {},
                securitySchemes: {}
            }
        };

        let canvasNodes = [];
        let selectedNode = null;
        let draggedPaletteItem = null;
        let isDraggingNode = false;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let canvasOffset = { x: 0, y: 0 };
        let zoomLevel = 1;
        let connectionStart = null;
        let tempConnection = null;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        let contextMenuTarget = null;

        // Icon mapping
        const SYSTEM_ICONS = {
            application: 'üíº',
            database: 'üóÑÔ∏è',
            service: '‚òÅÔ∏è',
            external: 'üåê',
            legacy: 'üñ•Ô∏è'
        };

        const PATTERN_ICONS = {
            'rest-api': 'üîå',
            'event-stream': 'üì®',
            'file-transfer': 'üìÅ',
            'messaging': 'üí¨',
            'batch': 'üì¶',
            'database-sync': 'üîÑ',
            'soap-api': 'üßº'
        };

        // ============ Initialization ============
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            setupCanvasInteractions();
            setupKeyboardShortcuts();
            saveHistory();
        });

        // ============ Drag and Drop ============
        function setupDragAndDrop() {
            document.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedPaletteItem = {
                        type: this.dataset.type,
                        subtype: this.dataset.subtype,
                        pattern: this.dataset.pattern
                    };
                    e.dataTransfer.effectAllowed = 'copy';
                });
            });

            const canvas = document.getElementById('canvas');
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!draggedPaletteItem) return;

                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvasOffset.x) / zoomLevel;
                const y = (e.clientY - rect.top - canvasOffset.y) / zoomLevel;

                if (draggedPaletteItem.type === 'system') {
                    createSystemNode(x, y, draggedPaletteItem.subtype);
                } else if (draggedPaletteItem.type === 'integration') {
                    createIntegrationNode(x, y, draggedPaletteItem.pattern);
                }

                draggedPaletteItem = null;
                saveHistory();
            });
        }

        // ============ Canvas Interactions ============
        function getEventCoords(e) {
            // Unified coordinate extraction for mouse, touch, and pointer events
            if (e.touches && e.touches.length > 0) {
                return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
            }
            return { clientX: e.clientX, clientY: e.clientY };
        }

        function setupCanvasInteractions() {
            const canvas = document.getElementById('canvas');
            const usePointerEvents = 'PointerEvent' in window;

            // Pan canvas - unified handler
            const handlePanStart = (e) => {
                if (e.target === canvas || e.target.id === 'canvasInner' || e.target.id === 'connectionsSvg') {
                    const { clientX, clientY } = getEventCoords(e);
                    isPanning = true;
                    panStart = { x: clientX - canvasOffset.x, y: clientY - canvasOffset.y };
                    canvas.classList.add('grabbing');
                }
            };

            const handlePanMove = (e) => {
                const { clientX, clientY } = getEventCoords(e);

                if (isPanning) {
                    canvasOffset.x = clientX - panStart.x;
                    canvasOffset.y = clientY - panStart.y;
                    updateCanvasTransform();
                }

                // Update temp connection line
                if (connectionStart && tempConnection) {
                    const rect = canvas.getBoundingClientRect();
                    const x = (clientX - rect.left - canvasOffset.x) / zoomLevel;
                    const y = (clientY - rect.top - canvasOffset.y) / zoomLevel;
                    updateTempConnection(x, y);
                }
            };

            const handlePanEnd = () => {
                isPanning = false;
                canvas.classList.remove('grabbing');
                // Note: Connection cleanup is handled by onConnectionEnd
            };

            // Use Pointer Events if available (better touch support)
            if (usePointerEvents) {
                canvas.addEventListener('pointerdown', handlePanStart);
                document.addEventListener('pointermove', handlePanMove);
                document.addEventListener('pointerup', handlePanEnd);
                document.addEventListener('pointercancel', handlePanEnd);
            } else {
                // Fallback to mouse events
                canvas.addEventListener('mousedown', handlePanStart);
                document.addEventListener('mousemove', handlePanMove);
                document.addEventListener('mouseup', handlePanEnd);

                // Add touch support for older browsers
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handlePanStart(e);
                });
                document.addEventListener('touchmove', (e) => {
                    if (isPanning || connectionStart) e.preventDefault();
                    handlePanMove(e);
                });
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handlePanEnd(e);
                });
            }

            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoomLevel = Math.max(0.1, Math.min(3, zoomLevel + delta));
                updateZoomDisplay();
                updateCanvasTransform();
            });

            // Click outside to deselect
            canvas.addEventListener('click', (e) => {
                if (e.target === canvas || e.target.id === 'canvasInner') {
                    deselectAll();
                }
            });

            // Context menu
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const target = e.target.closest('.system-node, .integration-node');
                if (target) {
                    contextMenuTarget = canvasNodes.find(n => {
                        const el = document.querySelector(`[data-node-id="${n.id}"]`);
                        return el === target;
                    });
                    showContextMenu(e.clientX, e.clientY);
                }
            });

            document.addEventListener('click', () => {
                hideContextMenu();
            });
        }

        // ============ Keyboard Shortcuts ============
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z: Undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                }
                // Ctrl+Y: Redo
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
                // Ctrl+S: Save/Export
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    exportJSON();
                }
                // Delete: Delete selected
                if (e.key === 'Delete' && selectedNode) {
                    deleteNode(selectedNode.id);
                }
                // ?: Toggle help
                if (e.key === '?') {
                    toggleHelp();
                }
                // Escape: Deselect
                if (e.key === 'Escape') {
                    deselectAll();
                    hideContextMenu();
                }
            });
        }

        // ============ Node Creation ============
        function createSystemNode(x, y, subtype) {
            const systemId = 'system-' + Date.now();
            const systemData = {
                name: subtype.charAt(0).toUpperCase() + subtype.slice(1) + ' System',
                type: subtype,
                description: '',
                owner: '',
                environment: 'development',
                version: ''
            };

            integrationData.systems[systemId] = systemData;

            const node = {
                id: systemId,
                type: 'system',
                subtype: subtype,
                data: systemData,
                x: x,
                y: y
            };

            canvasNodes.push(node);
            renderCanvas();
            clearEmptyState();
            return node;
        }

        function createIntegrationNode(x, y, pattern) {
            const integrationId = 'integration-' + Date.now();
            const integrationDef = {
                id: integrationId,
                name: pattern.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
                description: '',
                pattern: pattern,
                source: {
                    system: '',
                    protocol: '',
                    format: 'json'
                },
                target: {
                    system: '',
                    protocol: '',
                    format: 'json'
                },
                trigger: {
                    type: 'schedule'
                },
                transformation: {
                    type: 'mapping',
                    mapping: {}
                },
                errorHandling: {
                    retry: {
                        maxAttempts: 3,
                        backoff: 'exponential',
                        delay: '2s'
                    }
                },
                metadata: {
                    owner: '',
                    tags: []
                },
                config: {}
            };

            integrationData.integrations.push(integrationDef);

            const node = {
                id: integrationId,
                type: 'integration',
                pattern: pattern,
                data: integrationDef,
                x: x,
                y: y
            };

            canvasNodes.push(node);
            renderCanvas();
            clearEmptyState();
            return node;
        }

        // ============ Canvas Rendering ============
        function renderCanvas() {
            const canvasInner = document.getElementById('canvasInner');
            canvasInner.querySelectorAll('.system-node, .integration-node').forEach(n => n.remove());

            canvasNodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.className = node.type === 'system' ? 'system-node' : 'integration-node';
                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';
                nodeEl.dataset.nodeId = node.id;

                if (node.type === 'system') {
                    const icon = SYSTEM_ICONS[node.subtype] || 'üñ•Ô∏è';
                    nodeEl.innerHTML = `
                        <div class="node-icon">${icon}</div>
                        <div class="node-title">${node.data.name}</div>
                        <div class="node-subtitle">${node.subtype}</div>
                        <div class="connection-point top" data-node-id="${node.id}" data-position="top" title="Connect from top"></div>
                        <div class="connection-point right" data-node-id="${node.id}" data-position="right" title="Connect from right"></div>
                        <div class="connection-point bottom" data-node-id="${node.id}" data-position="bottom" title="Connect from bottom"></div>
                        <div class="connection-point left" data-node-id="${node.id}" data-position="left" title="Connect from left"></div>
                    `;
                } else {
                    const icon = PATTERN_ICONS[node.pattern] || 'üîå';
                    nodeEl.innerHTML = `
                        <div class="integration-icon">${icon}</div>
                        <div class="integration-title">${node.data.name}</div>
                        <div class="integration-pattern">${node.pattern}</div>
                        <div class="connection-point top" data-node-id="${node.id}" data-position="top" title="Connect from top"></div>
                        <div class="connection-point right" data-node-id="${node.id}" data-position="right" title="Connect from right"></div>
                        <div class="connection-point bottom" data-node-id="${node.id}" data-position="bottom" title="Connect from bottom"></div>
                        <div class="connection-point left" data-node-id="${node.id}" data-position="left" title="Connect from left"></div>
                    `;
                }

                // Click to select
                nodeEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectNode(node);
                });

                // Drag to move
                setupNodeDragging(nodeEl, node);

                // Connection points
                setupConnectionPoints(nodeEl, node);

                canvasInner.appendChild(nodeEl);
            });

            // Use requestAnimationFrame to ensure DOM layout is complete before calculating connections
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    renderConnections();
                });
            });
        }

        // ============ Node Dragging ============
        function setupNodeDragging(nodeEl, node) {
            let dragStartPos = { x: 0, y: 0 };
            let nodeDragStart = { x: 0, y: 0 };
            let isDragging = false;
            const usePointerEvents = 'PointerEvent' in window;

            const handleDragStart = (e) => {
                if (e.target.classList.contains('connection-point')) return;

                const { clientX, clientY } = getEventCoords(e);
                isDragging = true;
                nodeEl.classList.add('dragging');
                dragStartPos = { x: clientX, y: clientY };
                nodeDragStart = { x: node.x, y: node.y };
                e.preventDefault();
            };

            const handleDragMove = (e) => {
                if (!isDragging) return;

                const { clientX, clientY } = getEventCoords(e);
                const dx = (clientX - dragStartPos.x) / zoomLevel;
                const dy = (clientY - dragStartPos.y) / zoomLevel;

                node.x = nodeDragStart.x + dx;
                node.y = nodeDragStart.y + dy;

                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';

                renderConnections();
            };

            const handleDragEnd = () => {
                if (isDragging) {
                    isDragging = false;
                    nodeEl.classList.remove('dragging');
                    saveHistory();
                }
            };

            if (usePointerEvents) {
                nodeEl.addEventListener('pointerdown', handleDragStart);
                document.addEventListener('pointermove', handleDragMove);
                document.addEventListener('pointerup', handleDragEnd);
            } else {
                nodeEl.addEventListener('mousedown', handleDragStart);
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd);

                nodeEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleDragStart(e);
                });
            }
        }

        // ============ Connection Points ============
        function setupConnectionPoints(nodeEl, node) {
            const connectionPoints = nodeEl.querySelectorAll('.connection-point');
            const usePointerEvents = 'PointerEvent' in window;

            connectionPoints.forEach(point => {
                const handleConnectionStart = (e) => {
                    e.stopPropagation();
                    startConnection(node, point);
                };

                if (usePointerEvents) {
                    point.addEventListener('pointerdown', handleConnectionStart);
                } else {
                    point.addEventListener('mousedown', handleConnectionStart);
                    point.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleConnectionStart(e);
                    });
                }
            });
        }

        function startConnection(node, point) {
            const position = point.dataset.position;
            const usePointerEvents = 'PointerEvent' in window;

            connectionStart = {
                node: node,
                position: position,
                point: point
            };

            // Add visual feedback
            point.classList.add('connecting');

            // Create temporary connection path (bezier curve)
            const svg = document.getElementById('connectionsSvg');
            tempConnection = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempConnection.setAttribute('class', 'connection-line creating');
            tempConnection.setAttribute('stroke', '#8b5cf6');
            tempConnection.setAttribute('stroke-width', '3');
            tempConnection.setAttribute('fill', 'none');
            svg.appendChild(tempConnection);

            // Set up event listeners based on browser capability
            if (usePointerEvents) {
                document.addEventListener('pointermove', onConnectionMove);
                document.addEventListener('pointerup', onConnectionEnd, { once: true });
            } else {
                document.addEventListener('mousemove', onConnectionMove);
                document.addEventListener('mouseup', onConnectionEnd, { once: true });
                document.addEventListener('touchmove', onConnectionMove);
                document.addEventListener('touchend', onConnectionEnd, { once: true });
            }
        }

        function getConnectionPointCoordinates(node, position) {
            // Get the actual rendered dimensions and position from the DOM element
            const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);

            if (!nodeEl) {
                // Fallback if element not found
                const nodeWidth = node.type === 'system' ? 160 : 180;
                const nodeHeight = node.type === 'system' ? 120 : 110;

                switch(position) {
                    case 'top':
                        return { x: node.x + nodeWidth / 2, y: node.y };
                    case 'right':
                        return { x: node.x + nodeWidth, y: node.y + nodeHeight / 2 };
                    case 'bottom':
                        return { x: node.x + nodeWidth / 2, y: node.y + nodeHeight };
                    case 'left':
                        return { x: node.x, y: node.y + nodeHeight / 2 };
                    default:
                        return { x: node.x + nodeWidth / 2, y: node.y + nodeHeight / 2 };
                }
            }

            // Get the actual rendered dimensions
            const rect = nodeEl.getBoundingClientRect();
            const nodeWidth = nodeEl.offsetWidth;
            const nodeHeight = nodeEl.offsetHeight;

            // Since both the SVG and nodes are in the same coordinate space (canvasInner),
            // we use the node's position directly plus offsets
            switch(position) {
                case 'top':
                    return { x: node.x + nodeWidth / 2, y: node.y };
                case 'right':
                    return { x: node.x + nodeWidth, y: node.y + nodeHeight / 2 };
                case 'bottom':
                    return { x: node.x + nodeWidth / 2, y: node.y + nodeHeight };
                case 'left':
                    return { x: node.x, y: node.y + nodeHeight / 2 };
                default:
                    return { x: node.x + nodeWidth / 2, y: node.y + nodeHeight / 2 };
            }
        }

        function createBezierPath(x1, y1, x2, y2, dir1, dir2) {
            // Calculate control points based on connection directions
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const offset = Math.min(distance * 0.4, 150);

            let cx1, cy1, cx2, cy2;

            // First control point based on source direction
            switch(dir1) {
                case 'right':
                    cx1 = x1 + offset;
                    cy1 = y1;
                    break;
                case 'left':
                    cx1 = x1 - offset;
                    cy1 = y1;
                    break;
                case 'top':
                    cx1 = x1;
                    cy1 = y1 - offset;
                    break;
                case 'bottom':
                    cx1 = x1;
                    cy1 = y1 + offset;
                    break;
                default:
                    cx1 = x1 + offset;
                    cy1 = y1;
            }

            // Second control point based on target direction
            switch(dir2) {
                case 'right':
                    cx2 = x2 + offset;
                    cy2 = y2;
                    break;
                case 'left':
                    cx2 = x2 - offset;
                    cy2 = y2;
                    break;
                case 'top':
                    cx2 = x2;
                    cy2 = y2 - offset;
                    break;
                case 'bottom':
                    cx2 = x2;
                    cy2 = y2 + offset;
                    break;
                default:
                    cx2 = x2 - offset;
                    cy2 = y2;
            }

            return `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
        }

        function onConnectionMove(e) {
            if (!connectionStart || !tempConnection) return;

            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const startNode = connectionStart.node;
            const { clientX, clientY } = getEventCoords(e);

            // Get the connection point coordinates based on position
            const startCoords = getConnectionPointCoordinates(startNode, connectionStart.position);

            const endX = (clientX - rect.left - canvasOffset.x) / zoomLevel;
            const endY = (clientY - rect.top - canvasOffset.y) / zoomLevel;

            // Check for nearby connection points for snap feedback
            const snapDistance = 30;
            let nearestPoint = null;
            let minDist = snapDistance;

            document.querySelectorAll('.connection-point').forEach(point => {
                if (point === connectionStart.point) return;

                const pointRect = point.getBoundingClientRect();
                const pointX = (pointRect.left + pointRect.width / 2 - rect.left - canvasOffset.x) / zoomLevel;
                const pointY = (pointRect.top + pointRect.height / 2 - rect.top - canvasOffset.y) / zoomLevel;

                const dist = Math.sqrt((endX - pointX) ** 2 + (endY - pointY) ** 2);

                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = point;
                }
            });

            // Update snap visual feedback
            document.querySelectorAll('.connection-point.snap-target').forEach(p => {
                p.classList.remove('snap-target');
            });

            if (nearestPoint) {
                nearestPoint.classList.add('snap-target');
            }

            // Create bezier curve for smooth connection
            // Default to opposite direction for the end point
            const oppositeDir = {
                'top': 'bottom',
                'bottom': 'top',
                'left': 'right',
                'right': 'left'
            };
            const endDir = oppositeDir[connectionStart.position] || 'left';

            const pathData = createBezierPath(
                startCoords.x, startCoords.y,
                endX, endY,
                connectionStart.position,
                endDir
            );

            tempConnection.setAttribute('d', pathData);
        }

        function onConnectionEnd(e) {
            const usePointerEvents = 'PointerEvent' in window;

            // Remove event listeners
            if (usePointerEvents) {
                document.removeEventListener('pointermove', onConnectionMove);
            } else {
                document.removeEventListener('mousemove', onConnectionMove);
                document.removeEventListener('touchmove', onConnectionMove);
            }

            // Remove visual feedback
            if (connectionStart && connectionStart.point) {
                connectionStart.point.classList.remove('connecting');
            }

            // Remove snap-target highlights
            document.querySelectorAll('.connection-point.snap-target').forEach(p => {
                p.classList.remove('snap-target');
            });

            // Check if we ended on a connection point
            const target = e.target;
            if (target && target.classList && target.classList.contains('connection-point')) {
                const targetNodeId = target.dataset.nodeId;
                const targetNode = canvasNodes.find(n => n.id === targetNodeId);

                if (targetNode && targetNode.id !== connectionStart.node.id) {
                    createConnectionBetweenNodes(connectionStart.node, targetNode);
                    saveHistory();
                }
            }

            // Clean up
            if (tempConnection) {
                tempConnection.remove();
                tempConnection = null;
            }
            connectionStart = null;
        }

        function updateTempConnection(x, y) {
            if (!connectionStart || !tempConnection) return;

            const startNode = connectionStart.node;
            const startCoords = getConnectionPointCoordinates(startNode, connectionStart.position);

            // Create bezier curve for smooth connection
            const oppositeDir = {
                'top': 'bottom',
                'bottom': 'top',
                'left': 'right',
                'right': 'left'
            };
            const endDir = oppositeDir[connectionStart.position] || 'left';

            const pathData = createBezierPath(
                startCoords.x, startCoords.y,
                x, y,
                connectionStart.position,
                endDir
            );

            tempConnection.setAttribute('d', pathData);
        }

        function createConnectionBetweenNodes(node1, node2) {
            // Determine source and target based on node types
            let sourceNode, targetNode, integrationNode;

            if (node1.type === 'integration' && node2.type === 'system') {
                integrationNode = node1;
                // Check if we should set as source or target (prompt user or use heuristic)
                if (!integrationNode.data.source.system) {
                    integrationNode.data.source.system = node2.id;
                } else if (!integrationNode.data.target.system) {
                    integrationNode.data.target.system = node2.id;
                }
            } else if (node2.type === 'integration' && node1.type === 'system') {
                integrationNode = node2;
                if (!integrationNode.data.source.system) {
                    integrationNode.data.source.system = node1.id;
                } else if (!integrationNode.data.target.system) {
                    integrationNode.data.target.system = node1.id;
                }
            } else if (node1.type === 'system' && node2.type === 'system') {
                // Create integration between two systems
                const midX = (node1.x + node2.x) / 2;
                const midY = (node1.y + node2.y) / 2;
                const integration = createIntegrationNode(midX, midY, 'rest-api');
                integration.data.source.system = node1.id;
                integration.data.target.system = node2.id;
            }

            // Update integration in data
            const integration = integrationData.integrations.find(i => i.id === integrationNode?.id);
            if (integration && integrationNode) {
                integration.source.system = integrationNode.data.source.system;
                integration.target.system = integrationNode.data.target.system;
            }

            renderCanvas();
            showAlert('success', 'Connection created! Configure it in the properties panel.');
        }

        // ============ Render Connections ============
        function renderConnections() {
            const svg = document.getElementById('connectionsSvg');
            svg.querySelectorAll('path:not(.creating), text, rect').forEach(el => el.remove());

            canvasNodes.filter(n => n.type === 'integration').forEach(integration => {
                const sourceSystemId = integration.data.source?.system;
                const targetSystemId = integration.data.target?.system;

                const sourceNode = canvasNodes.find(n => n.id === sourceSystemId);
                const targetNode = canvasNodes.find(n => n.id === targetSystemId);

                // Calculate optimal connection positions
                let sourcePos = 'right';
                let targetPos = 'left';
                let integrationSourcePos = 'left';
                let integrationTargetPos = 'right';

                // Draw source connection
                if (sourceNode) {
                    // Determine best connection point based on relative positions
                    const dx = integration.x - sourceNode.x;
                    const dy = integration.y - sourceNode.y;

                    if (Math.abs(dx) > Math.abs(dy)) {
                        sourcePos = dx > 0 ? 'right' : 'left';
                        integrationSourcePos = dx > 0 ? 'left' : 'right';
                    } else {
                        sourcePos = dy > 0 ? 'bottom' : 'top';
                        integrationSourcePos = dy > 0 ? 'top' : 'bottom';
                    }

                    const sourceCoords = getConnectionPointCoordinates(sourceNode, sourcePos);
                    const integrationSourceCoords = getConnectionPointCoordinates(integration, integrationSourcePos);

                    // Create bezier curve connection
                    const pathData = createBezierPath(
                        sourceCoords.x, sourceCoords.y,
                        integrationSourceCoords.x, integrationSourceCoords.y,
                        sourcePos, integrationSourcePos
                    );

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'connection-line');
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', '#8b5cf6');
                    path.setAttribute('stroke-width', '3');
                    path.setAttribute('fill', 'none');
                    svg.appendChild(path);
                }

                // Draw target connection
                if (targetNode) {
                    // Determine best connection point based on relative positions
                    const dx = targetNode.x - integration.x;
                    const dy = targetNode.y - integration.y;

                    if (Math.abs(dx) > Math.abs(dy)) {
                        integrationTargetPos = dx > 0 ? 'right' : 'left';
                        targetPos = dx > 0 ? 'left' : 'right';
                    } else {
                        integrationTargetPos = dy > 0 ? 'bottom' : 'top';
                        targetPos = dy > 0 ? 'top' : 'bottom';
                    }

                    const integrationTargetCoords = getConnectionPointCoordinates(integration, integrationTargetPos);
                    const targetCoords = getConnectionPointCoordinates(targetNode, targetPos);

                    // Create bezier curve connection
                    const pathData = createBezierPath(
                        integrationTargetCoords.x, integrationTargetCoords.y,
                        targetCoords.x, targetCoords.y,
                        integrationTargetPos, targetPos
                    );

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('class', 'connection-line');
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', '#8b5cf6');
                    path.setAttribute('stroke-width', '3');
                    path.setAttribute('fill', 'none');
                    svg.appendChild(path);

                    // Add label at midpoint
                    const midX = (integrationTargetCoords.x + targetCoords.x) / 2;
                    const midY = (integrationTargetCoords.y + targetCoords.y) / 2;

                    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    bgRect.setAttribute('class', 'connection-label-bg');
                    bgRect.setAttribute('x', midX - 35);
                    bgRect.setAttribute('y', midY - 10);
                    bgRect.setAttribute('width', 70);
                    bgRect.setAttribute('height', 20);
                    bgRect.setAttribute('rx', 4);
                    svg.appendChild(bgRect);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('class', 'connection-label');
                    text.setAttribute('x', midX);
                    text.setAttribute('y', midY + 4);
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = integration.data.pattern;
                    svg.appendChild(text);
                }
            });
        }

        // ============ Node Selection ============
        function selectNode(node) {
            selectedNode = node;

            document.querySelectorAll('.system-node, .integration-node').forEach(n => {
                n.classList.remove('selected');
            });
            document.querySelector(`[data-node-id="${node.id}"]`)?.classList.add('selected');

            showProperties(node);
        }

        function deselectAll() {
            selectedNode = null;
            document.querySelectorAll('.system-node, .integration-node').forEach(n => {
                n.classList.remove('selected');
            });
            document.getElementById('propertiesPanel').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">‚öôÔ∏è</div>
                    <h3>Properties</h3>
                    <p>Select a component to edit its properties</p>
                    <p style="margin-top: 1rem; font-size: 0.75rem;">üí° <strong>Tip:</strong> Click & drag from purple connection points (each node has 4: ‚¨ÜÔ∏è‚û°Ô∏è‚¨áÔ∏è‚¨ÖÔ∏è)</p>
                </div>
            `;
        }

        // ============ Properties Panel ============
        function showProperties(node) {
            const panel = document.getElementById('propertiesPanel');

            if (node.type === 'system') {
                panel.innerHTML = `
                    <div class="properties-header">
                        <h3>üñ•Ô∏è System Properties</h3>
                        <button class="btn btn-danger btn-icon" onclick="deleteNode('${node.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="form-section">
                        <div class="form-section-title">Basic Information</div>
                        <div class="form-group">
                            <label>Name <span class="required">*</span></label>
                            <input type="text" value="${node.data.name}" onchange="updateNodeData('${node.id}', 'name', this.value)">
                            <div class="form-help">Display name for this system</div>
                        </div>
                        <div class="form-group">
                            <label>Type <span class="required">*</span></label>
                            <select onchange="updateNodeData('${node.id}', 'type', this.value)" value="${node.data.type}">
                                <option value="application" ${node.data.type === 'application' ? 'selected' : ''}>Application</option>
                                <option value="database" ${node.data.type === 'database' ? 'selected' : ''}>Database</option>
                                <option value="service" ${node.data.type === 'service' ? 'selected' : ''}>Service</option>
                                <option value="external" ${node.data.type === 'external' ? 'selected' : ''}>External</option>
                                <option value="legacy" ${node.data.type === 'legacy' ? 'selected' : ''}>Legacy</option>
                                <option value="api-gateway" ${node.data.type === 'api-gateway' ? 'selected' : ''}>API Gateway</option>
                                <option value="message-broker" ${node.data.type === 'message-broker' ? 'selected' : ''}>Message Broker</option>
                                <option value="cache" ${node.data.type === 'cache' ? 'selected' : ''}>Cache</option>
                                <option value="file-storage" ${node.data.type === 'file-storage' ? 'selected' : ''}>File Storage</option>
                                <option value="data-warehouse" ${node.data.type === 'data-warehouse' ? 'selected' : ''}>Data Warehouse</option>
                                <option value="etl" ${node.data.type === 'etl' ? 'selected' : ''}>ETL Tool</option>
                                <option value="container" ${node.data.type === 'container' ? 'selected' : ''}>Container</option>
                                <option value="serverless" ${node.data.type === 'serverless' ? 'selected' : ''}>Serverless</option>
                                <option value="auth" ${node.data.type === 'auth' ? 'selected' : ''}>Auth Service</option>
                                <option value="monitoring" ${node.data.type === 'monitoring' ? 'selected' : ''}>Monitoring</option>
                                <option value="cdn" ${node.data.type === 'cdn' ? 'selected' : ''}>CDN</option>
                                <option value="analytics" ${node.data.type === 'analytics' ? 'selected' : ''}>Analytics</option>
                                <option value="crm" ${node.data.type === 'crm' ? 'selected' : ''}>CRM</option>
                                <option value="erp" ${node.data.type === 'erp' ? 'selected' : ''}>ERP</option>
                                <option value="hr" ${node.data.type === 'hr' ? 'selected' : ''}>HR System</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Description</label>
                            <textarea onchange="updateNodeData('${node.id}', 'description', this.value)">${node.data.description || ''}</textarea>
                            <div class="form-help">Describe the purpose and role of this system</div>
                        </div>
                        <div class="form-group">
                            <label>Version</label>
                            <input type="text" value="${node.data.version || ''}" onchange="updateNodeData('${node.id}', 'version', this.value)">
                            <div class="form-help">System version or release</div>
                        </div>
                        <div class="form-group">
                            <label>Owner</label>
                            <input type="text" value="${node.data.owner || ''}" onchange="updateNodeData('${node.id}', 'owner', this.value)">
                            <div class="form-help">Team or person responsible</div>
                        </div>
                        <div class="form-group">
                            <label>Environment</label>
                            <select onchange="updateNodeData('${node.id}', 'environment', this.value)">
                                <option value="development" ${node.data.environment === 'development' ? 'selected' : ''}>Development</option>
                                <option value="test" ${node.data.environment === 'test' ? 'selected' : ''}>Test</option>
                                <option value="staging" ${node.data.environment === 'staging' ? 'selected' : ''}>Staging</option>
                                <option value="production" ${node.data.environment === 'production' ? 'selected' : ''}>Production</option>
                            </select>
                        </div>
                    </div>
                `;
            } else if (node.type === 'integration') {
                const systemOptions = Object.keys(integrationData.systems).map(sysId => {
                    const sys = integrationData.systems[sysId];
                    return `<option value="${sysId}" ${node.data.source.system === sysId || node.data.target.system === sysId ? 'selected' : ''}>${sys.name}</option>`;
                }).join('');

                panel.innerHTML = `
                    <div class="properties-header">
                        <h3>üîå Integration Properties</h3>
                        <button class="btn btn-danger btn-icon" onclick="deleteNode('${node.id}')" title="Delete">üóëÔ∏è</button>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Basic Information</div>
                        <div class="form-group">
                            <label>Name <span class="required">*</span></label>
                            <input type="text" value="${node.data.name}" onchange="updateIntegrationData('${node.id}', 'name', this.value)">
                        </div>
                        <div class="form-group">
                            <label>Description</label>
                            <textarea onchange="updateIntegrationData('${node.id}', 'description', this.value)">${node.data.description || ''}</textarea>
                            <div class="form-help">Describe what this integration does</div>
                        </div>
                        <div class="form-group">
                            <label>Pattern <span class="required">*</span></label>
                            <select disabled>
                                <option value="${node.data.pattern}">${node.data.pattern}</option>
                            </select>
                            <div class="form-help">Pattern cannot be changed after creation</div>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Source Configuration</div>
                        <div class="form-group">
                            <label>Source System <span class="required">*</span></label>
                            <select onchange="updateIntegrationEndpoint('${node.id}', 'source', 'system', this.value)">
                                <option value="">Select system...</option>
                                ${systemOptions}
                            </select>
                            <div class="form-help">Where data comes from</div>
                        </div>
                        <div class="form-group">
                            <label>Protocol</label>
                            <input type="text" value="${node.data.source.protocol || ''}" onchange="updateIntegrationEndpoint('${node.id}', 'source', 'protocol', this.value)" placeholder="e.g., https, kafka, sftp">
                        </div>
                        <div class="form-group">
                            <label>Format</label>
                            <select onchange="updateIntegrationEndpoint('${node.id}', 'source', 'format', this.value)">
                                <option value="json" ${node.data.source.format === 'json' ? 'selected' : ''}>JSON</option>
                                <option value="xml" ${node.data.source.format === 'xml' ? 'selected' : ''}>XML</option>
                                <option value="csv" ${node.data.source.format === 'csv' ? 'selected' : ''}>CSV</option>
                                <option value="avro" ${node.data.source.format === 'avro' ? 'selected' : ''}>Avro</option>
                                <option value="protobuf" ${node.data.source.format === 'protobuf' ? 'selected' : ''}>Protocol Buffers</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Target Configuration</div>
                        <div class="form-group">
                            <label>Target System <span class="required">*</span></label>
                            <select onchange="updateIntegrationEndpoint('${node.id}', 'target', 'system', this.value)">
                                <option value="">Select system...</option>
                                ${systemOptions}
                            </select>
                            <div class="form-help">Where data goes to</div>
                        </div>
                        <div class="form-group">
                            <label>Protocol</label>
                            <input type="text" value="${node.data.target.protocol || ''}" onchange="updateIntegrationEndpoint('${node.id}', 'target', 'protocol', this.value)" placeholder="e.g., https, kafka, jdbc">
                        </div>
                        <div class="form-group">
                            <label>Format</label>
                            <select onchange="updateIntegrationEndpoint('${node.id}', 'target', 'format', this.value)">
                                <option value="json" ${node.data.target.format === 'json' ? 'selected' : ''}>JSON</option>
                                <option value="xml" ${node.data.target.format === 'xml' ? 'selected' : ''}>XML</option>
                                <option value="csv" ${node.data.target.format === 'csv' ? 'selected' : ''}>CSV</option>
                                <option value="avro" ${node.data.target.format === 'avro' ? 'selected' : ''}>Avro</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Trigger Configuration</div>
                        <div class="form-group">
                            <label>Trigger Type</label>
                            <select onchange="updateIntegrationTrigger('${node.id}', 'type', this.value)">
                                <option value="schedule" ${node.data.trigger.type === 'schedule' ? 'selected' : ''}>Schedule (cron)</option>
                                <option value="event" ${node.data.trigger.type === 'event' ? 'selected' : ''}>Event</option>
                                <option value="api-call" ${node.data.trigger.type === 'api-call' ? 'selected' : ''}>API Call</option>
                                <option value="webhook" ${node.data.trigger.type === 'webhook' ? 'selected' : ''}>Webhook</option>
                                <option value="file-arrival" ${node.data.trigger.type === 'file-arrival' ? 'selected' : ''}>File Arrival</option>
                                <option value="database-change" ${node.data.trigger.type === 'database-change' ? 'selected' : ''}>Database Change</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Connection Configuration</div>
                        <div class="form-group">
                            <label>Source URL/Endpoint</label>
                            <input type="text" value="${node.data.source.connection?.url || ''}" onchange="updateIntegrationConnection('${node.id}', 'source', 'url', this.value)" placeholder="e.g., https://api.example.com">
                            <div class="form-help">Connection URL or endpoint for source system</div>
                        </div>
                        <div class="form-group">
                            <label>Target URL/Endpoint</label>
                            <input type="text" value="${node.data.target.connection?.url || ''}" onchange="updateIntegrationConnection('${node.id}', 'target', 'url', this.value)" placeholder="e.g., https://target.example.com">
                            <div class="form-help">Connection URL or endpoint for target system</div>
                        </div>
                        <div class="form-group">
                            <label>Timeout (seconds)</label>
                            <input type="number" value="${parseInt(node.data.config?.timeout) || 30}" onchange="updateIntegrationConfig('${node.id}', 'timeout', this.value + 's')" min="1" max="300">
                            <div class="form-help">Request timeout in seconds</div>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Error Handling</div>
                        <div class="form-group">
                            <label>Enable Retry</label>
                            <select onchange="updateIntegrationErrorHandling('${node.id}', 'retry.enabled', this.value === 'true')">
                                <option value="true" ${node.data.errorHandling?.retry?.maxAttempts ? 'selected' : ''}>Enabled</option>
                                <option value="false" ${!node.data.errorHandling?.retry?.maxAttempts ? 'selected' : ''}>Disabled</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Max Retry Attempts</label>
                            <input type="number" value="${node.data.errorHandling?.retry?.maxAttempts || 3}" onchange="updateIntegrationErrorHandling('${node.id}', 'retry.maxAttempts', parseInt(this.value))" min="0" max="10">
                            <div class="form-help">Number of retry attempts on failure</div>
                        </div>
                        <div class="form-group">
                            <label>Retry Strategy</label>
                            <select onchange="updateIntegrationErrorHandling('${node.id}', 'retry.backoff', this.value)">
                                <option value="fixed" ${node.data.errorHandling?.retry?.backoff === 'fixed' ? 'selected' : ''}>Fixed Delay</option>
                                <option value="exponential" ${node.data.errorHandling?.retry?.backoff === 'exponential' ? 'selected' : ''}>Exponential Backoff</option>
                                <option value="linear" ${node.data.errorHandling?.retry?.backoff === 'linear' ? 'selected' : ''}>Linear Backoff</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Dead Letter Queue</label>
                            <select onchange="updateIntegrationErrorHandling('${node.id}', 'deadLetterQueue.enabled', this.value === 'true')">
                                <option value="true" ${node.data.errorHandling?.deadLetterQueue?.enabled ? 'selected' : ''}>Enabled</option>
                                <option value="false" ${!node.data.errorHandling?.deadLetterQueue?.enabled ? 'selected' : ''}>Disabled</option>
                            </select>
                            <div class="form-help">Send failed messages to dead letter queue</div>
                        </div>
                        <div class="form-group">
                            <label>Enable Alerting</label>
                            <select onchange="updateIntegrationErrorHandling('${node.id}', 'alerting.enabled', this.value === 'true')">
                                <option value="true" ${node.data.errorHandling?.alerting?.enabled ? 'selected' : ''}>Enabled</option>
                                <option value="false" ${!node.data.errorHandling?.alerting?.enabled ? 'selected' : ''}>Disabled</option>
                            </select>
                            <div class="form-help">Send alerts on errors</div>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Security</div>
                        <div class="form-group">
                            <label>Authentication Type</label>
                            <select onchange="updateIntegrationSecurity('${node.id}', 'authType', this.value)">
                                <option value="none" ${!node.data.security || node.data.security.length === 0 ? 'selected' : ''}>None</option>
                                <option value="oauth2" ${node.data.security?.some(s => s.oauth2) ? 'selected' : ''}>OAuth 2.0</option>
                                <option value="api-key" ${node.data.security?.some(s => s.apiKey) ? 'selected' : ''}>API Key</option>
                                <option value="basic" ${node.data.security?.some(s => s.basic) ? 'selected' : ''}>Basic Auth</option>
                                <option value="jwt" ${node.data.security?.some(s => s.jwt) ? 'selected' : ''}>JWT</option>
                                <option value="mtls" ${node.data.security?.some(s => s.mtls) ? 'selected' : ''}>Mutual TLS</option>
                            </select>
                            <div class="form-help">Authentication mechanism for this integration</div>
                        </div>
                        <div class="form-group">
                            <label>Encryption</label>
                            <select onchange="updateIntegrationSecurity('${node.id}', 'encryption', this.value)">
                                <option value="tls" selected>TLS/HTTPS</option>
                                <option value="none">None (not recommended)</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Performance & SLA</div>
                        <div class="form-group">
                            <label>Expected Latency</label>
                            <input type="text" value="${node.data.metadata?.sla?.latency || ''}" onchange="updateIntegrationSLA('${node.id}', 'latency', this.value)" placeholder="e.g., 5s, 100ms">
                            <div class="form-help">Maximum acceptable latency</div>
                        </div>
                        <div class="form-group">
                            <label>Throughput Target</label>
                            <input type="text" value="${node.data.metadata?.sla?.throughput || ''}" onchange="updateIntegrationSLA('${node.id}', 'throughput', this.value)" placeholder="e.g., 100/min, 1000/sec">
                            <div class="form-help">Expected throughput rate</div>
                        </div>
                        <div class="form-group">
                            <label>Availability SLA</label>
                            <input type="text" value="${node.data.metadata?.sla?.availability || ''}" onchange="updateIntegrationSLA('${node.id}', 'availability', this.value)" placeholder="e.g., 99.9%, 99.99%">
                            <div class="form-help">Target availability percentage</div>
                        </div>
                    </div>

                    <div class="form-section">
                        <div class="form-section-title">Metadata</div>
                        <div class="form-group">
                            <label>Owner</label>
                            <input type="text" value="${node.data.metadata.owner || ''}" onchange="updateIntegrationMetadata('${node.id}', 'owner', this.value)">
                            <div class="form-help">Team or person responsible</div>
                        </div>
                        <div class="form-group">
                            <label>Tags</label>
                            <input type="text" value="${(node.data.metadata.tags || []).join(', ')}" onchange="updateIntegrationMetadata('${node.id}', 'tags', this.value.split(',').map(t => t.trim()))">
                            <div class="form-help">Comma-separated tags for categorization</div>
                        </div>
                        <div class="form-group">
                            <label>Documentation URL</label>
                            <input type="text" value="${node.data.metadata?.documentation || ''}" onchange="updateIntegrationMetadata('${node.id}', 'documentation', this.value)" placeholder="https://wiki.example.com/...">
                            <div class="form-help">Link to integration documentation</div>
                        </div>
                    </div>
                `;
            }
        }

        // ============ Update Functions ============
        function updateNodeData(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'system') {
                node.data[field] = value;
                integrationData.systems[nodeId][field] = value;
                renderCanvas();
                saveHistory();
            }
        }

        function updateIntegrationData(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                node.data[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    integration[field] = value;
                }
                renderCanvas();
                saveHistory();
            }
        }

        function updateIntegrationEndpoint(nodeId, endpoint, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                node.data[endpoint][field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    integration[endpoint][field] = value;
                }
                renderCanvas();
                saveHistory();
            }
        }

        function updateIntegrationTrigger(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                node.data.trigger[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    integration.trigger[field] = value;
                }
                saveHistory();
            }
        }

        function updateIntegrationMetadata(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                node.data.metadata[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    integration.metadata[field] = value;
                }
                saveHistory();
            }
        }

        function updateIntegrationConnection(nodeId, endpoint, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                if (!node.data[endpoint].connection) {
                    node.data[endpoint].connection = {};
                }
                node.data[endpoint].connection[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    if (!integration[endpoint].connection) {
                        integration[endpoint].connection = {};
                    }
                    integration[endpoint].connection[field] = value;
                }
                saveHistory();
            }
        }

        function updateIntegrationConfig(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                if (!node.data.config) {
                    node.data.config = {};
                }
                node.data.config[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    if (!integration.config) {
                        integration.config = {};
                    }
                    integration.config[field] = value;
                }
                saveHistory();
            }
        }

        function updateIntegrationErrorHandling(nodeId, path, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                if (!node.data.errorHandling) {
                    node.data.errorHandling = { retry: {}, deadLetterQueue: {}, alerting: {} };
                }

                // Handle nested path like 'retry.maxAttempts'
                const parts = path.split('.');
                let target = node.data.errorHandling;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!target[parts[i]]) {
                        target[parts[i]] = {};
                    }
                    target = target[parts[i]];
                }
                target[parts[parts.length - 1]] = value;

                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    if (!integration.errorHandling) {
                        integration.errorHandling = { retry: {}, deadLetterQueue: {}, alerting: {} };
                    }
                    target = integration.errorHandling;
                    for (let i = 0; i < parts.length - 1; i++) {
                        if (!target[parts[i]]) {
                            target[parts[i]] = {};
                        }
                        target = target[parts[i]];
                    }
                    target[parts[parts.length - 1]] = value;
                }
                saveHistory();
            }
        }

        function updateIntegrationSecurity(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                if (!node.data.security) {
                    node.data.security = [];
                }

                // Update security based on auth type
                if (field === 'authType') {
                    if (value === 'none') {
                        node.data.security = [];
                    } else {
                        const securityObj = {};
                        securityObj[value] = [];
                        node.data.security = [securityObj];
                    }
                } else {
                    // Handle other security fields
                    if (node.data.security.length === 0) {
                        node.data.security.push({});
                    }
                    node.data.security[0][field] = value;
                }

                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    integration.security = JSON.parse(JSON.stringify(node.data.security));
                }
                saveHistory();
            }
        }

        function updateIntegrationSLA(nodeId, field, value) {
            const node = canvasNodes.find(n => n.id === nodeId);
            if (node && node.type === 'integration') {
                if (!node.data.metadata.sla) {
                    node.data.metadata.sla = {};
                }
                node.data.metadata.sla[field] = value;
                const integration = integrationData.integrations.find(i => i.id === nodeId);
                if (integration) {
                    if (!integration.metadata.sla) {
                        integration.metadata.sla = {};
                    }
                    integration.metadata.sla[field] = value;
                }
                saveHistory();
            }
        }

        // ============ Delete Node ============
        function deleteNode(nodeId) {
            if (confirm('Are you sure you want to delete this component?')) {
                const node = canvasNodes.find(n => n.id === nodeId);
                if (node) {
                    if (node.type === 'system') {
                        delete integrationData.systems[nodeId];
                        // Remove references in integrations
                        integrationData.integrations.forEach(i => {
                            if (i.source.system === nodeId) i.source.system = '';
                            if (i.target.system === nodeId) i.target.system = '';
                        });
                    } else {
                        integrationData.integrations = integrationData.integrations.filter(i => i.id !== nodeId);
                    }
                    canvasNodes = canvasNodes.filter(n => n.id !== nodeId);
                    renderCanvas();
                    deselectAll();
                    saveHistory();
                }
            }
        }

        // ============ Canvas Transform ============
        function updateCanvasTransform() {
            const canvasInner = document.getElementById('canvasInner');
            const svg = document.getElementById('connectionsSvg');
            const transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
            canvasInner.style.transform = transform;
            svg.style.transform = transform;
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        // ============ Zoom Controls ============
        function zoomIn() {
            zoomLevel = Math.min(3, zoomLevel + 0.1);
            updateZoomDisplay();
            updateCanvasTransform();
        }

        function zoomOut() {
            zoomLevel = Math.max(0.1, zoomLevel - 0.1);
            updateZoomDisplay();
            updateCanvasTransform();
        }

        function resetZoom() {
            zoomLevel = 1;
            canvasOffset = { x: 0, y: 0 };
            updateZoomDisplay();
            updateCanvasTransform();
        }

        function fitToView() {
            if (canvasNodes.length === 0) return;

            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();

            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            canvasNodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 200);
                maxY = Math.max(maxY, node.y + 150);
            });

            const width = maxX - minX;
            const height = maxY - minY;
            const scale = Math.min(rect.width / width, rect.height / height, 1) * 0.9;

            zoomLevel = scale;
            canvasOffset.x = (rect.width - width * scale) / 2 - minX * scale;
            canvasOffset.y = (rect.height - height * scale) / 2 - minY * scale;

            updateZoomDisplay();
            updateCanvasTransform();
        }

        // ============ Auto Layout ============
        function autoLayout() {
            if (canvasNodes.length === 0) return;

            const systems = canvasNodes.filter(n => n.type === 'system');
            const integrations = canvasNodes.filter(n => n.type === 'integration');

            // Position systems in a circle
            const radius = 300;
            const centerX = 400;
            const centerY = 300;

            systems.forEach((node, i) => {
                const angle = (i / systems.length) * 2 * Math.PI;
                node.x = centerX + radius * Math.cos(angle);
                node.y = centerY + radius * Math.sin(angle);
            });

            // Position integrations in the middle
            integrations.forEach((node, i) => {
                const angle = (i / integrations.length) * 2 * Math.PI + Math.PI / integrations.length;
                node.x = centerX + (radius / 2) * Math.cos(angle);
                node.y = centerY + (radius / 2) * Math.sin(angle);
            });

            renderCanvas();
            fitToView();
            saveHistory();
            showAlert('success', 'Layout optimized!');
        }

        // ============ History (Undo/Redo) ============
        function saveHistory() {
            const state = {
                nodes: JSON.parse(JSON.stringify(canvasNodes)),
                data: JSON.parse(JSON.stringify(integrationData))
            };

            // Remove future history
            history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;

            // Limit history size
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }

            updateHistoryButtons();
            updateValidationIndicator();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreHistory();
                showAlert('info', 'Undo successful');
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreHistory();
                showAlert('info', 'Redo successful');
            }
        }

        function restoreHistory() {
            if (historyIndex >= 0 && historyIndex < history.length) {
                const state = history[historyIndex];
                canvasNodes = JSON.parse(JSON.stringify(state.nodes));
                integrationData = JSON.parse(JSON.stringify(state.data));
                renderCanvas();
                deselectAll();
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }

        // ============ Context Menu ============
        function showContextMenu(x, y) {
            const menu = document.getElementById('contextMenu');
            menu.classList.add('active');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('active');
        }

        function contextAction(action) {
            hideContextMenu();
            if (!contextMenuTarget) return;

            switch(action) {
                case 'edit':
                    selectNode(contextMenuTarget);
                    break;
                case 'duplicate':
                    duplicateNode(contextMenuTarget);
                    break;
                case 'delete':
                    deleteNode(contextMenuTarget.id);
                    break;
            }
            contextMenuTarget = null;
        }

        function duplicateNode(node) {
            const newNode = JSON.parse(JSON.stringify(node));
            newNode.id = node.type + '-' + Date.now();
            newNode.x += 50;
            newNode.y += 50;
            newNode.data.name += ' (Copy)';

            if (node.type === 'system') {
                integrationData.systems[newNode.id] = newNode.data;
            } else {
                newNode.data.id = newNode.id;
                integrationData.integrations.push(newNode.data);
            }

            canvasNodes.push(newNode);
            renderCanvas();
            saveHistory();
            showAlert('success', 'Node duplicated!');
        }

        // ============ Export Functions ============
        // ============ Validation ============
        function validateIntegrationData() {
            const errors = [];
            const warnings = [];

            // Validate info section
            if (!integrationData.info.title || integrationData.info.title.trim() === '') {
                errors.push('Integration title is required');
            }
            if (!integrationData.info.version || integrationData.info.version.trim() === '') {
                warnings.push('Integration version is missing');
            }

            // Validate systems
            const systemIds = Object.keys(integrationData.systems || {});
            if (systemIds.length === 0) {
                warnings.push('No systems defined - add at least one system');
            }

            systemIds.forEach(sysId => {
                const system = integrationData.systems[sysId];
                if (!system.name || system.name.trim() === '') {
                    errors.push(`System '${sysId}' is missing a name`);
                }
                if (!system.type || system.type.trim() === '') {
                    errors.push(`System '${sysId}' is missing a type`);
                }
            });

            // Validate integrations
            if (integrationData.integrations.length === 0) {
                warnings.push('No integrations defined - add at least one integration');
            }

            integrationData.integrations.forEach((integration, idx) => {
                const intId = integration.id || `Integration ${idx + 1}`;

                if (!integration.name || integration.name.trim() === '') {
                    errors.push(`${intId} is missing a name`);
                }
                if (!integration.pattern) {
                    errors.push(`${intId} is missing a pattern`);
                }

                // Validate source
                if (!integration.source) {
                    errors.push(`${intId} is missing source configuration`);
                } else {
                    if (!integration.source.system) {
                        errors.push(`${intId} source system is not set`);
                    } else if (!systemIds.includes(integration.source.system)) {
                        errors.push(`${intId} references non-existent source system '${integration.source.system}'`);
                    }
                    if (!integration.source.protocol) {
                        warnings.push(`${intId} source protocol is not set`);
                    }
                }

                // Validate target
                if (!integration.target) {
                    errors.push(`${intId} is missing target configuration`);
                } else {
                    if (!integration.target.system) {
                        errors.push(`${intId} target system is not set`);
                    } else if (!systemIds.includes(integration.target.system)) {
                        errors.push(`${intId} references non-existent target system '${integration.target.system}'`);
                    }
                    if (!integration.target.protocol) {
                        warnings.push(`${intId} target protocol is not set`);
                    }
                }

                // Validate security
                if (!integration.security || integration.security.length === 0) {
                    warnings.push(`${intId} has no security configuration`);
                }

                // Validate error handling
                if (!integration.errorHandling) {
                    warnings.push(`${intId} has no error handling configuration`);
                }

                // Validate connection URLs
                if (integration.source?.connection && !integration.source.connection.url) {
                    warnings.push(`${intId} source connection URL is not set`);
                }
                if (integration.target?.connection && !integration.target.connection.url) {
                    warnings.push(`${intId} target connection URL is not set`);
                }
            });

            return { errors, warnings };
        }

        function showValidationResults() {
            const { errors, warnings } = validateIntegrationData();
            const totalIssues = errors.length + warnings.length;

            if (totalIssues === 0) {
                showAlert('success', 'Validation passed! No errors or warnings found.');
                return;
            }

            let message = '<div style="text-align: left; max-height: 400px; overflow-y: auto;">';

            if (errors.length > 0) {
                message += '<h4 style="color: #ef4444; margin-top: 0;">‚ùå Errors (' + errors.length + ')</h4><ul style="margin: 0.5rem 0;">';
                errors.forEach(err => {
                    message += '<li style="margin: 0.25rem 0;">' + err + '</li>';
                });
                message += '</ul>';
            }

            if (warnings.length > 0) {
                message += '<h4 style="color: #f59e0b; margin-top: 1rem;">‚ö†Ô∏è Warnings (' + warnings.length + ')</h4><ul style="margin: 0.5rem 0;">';
                warnings.forEach(warn => {
                    message += '<li style="margin: 0.25rem 0;">' + warn + '</li>';
                });
                message += '</ul>';
            }

            message += '</div>';

            // Create custom modal for validation results
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Validation Results</h2>
                        <button class="close-btn" onclick="this.closest('.modal').remove()">‚úï</button>
                    </div>
                    ${message}
                </div>
            `;
            document.body.appendChild(modal);
        }

        function updateValidationIndicator() {
            const { errors, warnings } = validateIntegrationData();
            const indicator = document.getElementById('validationIndicator');
            if (!indicator) return;

            const totalIssues = errors.length + warnings.length;

            if (totalIssues === 0) {
                indicator.innerHTML = '‚úÖ Valid';
                indicator.style.color = '#10b981';
                indicator.title = 'No validation issues';
            } else if (errors.length > 0) {
                indicator.innerHTML = `‚ùå ${errors.length} Error${errors.length > 1 ? 's' : ''}`;
                indicator.style.color = '#ef4444';
                indicator.title = `${errors.length} error(s), ${warnings.length} warning(s)`;
            } else {
                indicator.innerHTML = `‚ö†Ô∏è ${warnings.length} Warning${warnings.length > 1 ? 's' : ''}`;
                indicator.style.color = '#f59e0b';
                indicator.title = `${warnings.length} warning(s)`;
            }
        }

        function exportJSON() {
            const json = JSON.stringify(integrationData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${integrationData.info.title.toLowerCase().replace(/\s+/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showAlert('success', 'JSON exported successfully!');
        }

        function exportAsPNG() {
            showAlert('info', 'PNG export coming soon! Use browser screenshot for now.');
            // TODO: Implement canvas to PNG export
        }

        // ============ Load Functions ============
        function loadJSONFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    loadIntegrationData(json);
                    showAlert('success', 'JSON file loaded successfully!');
                } catch (error) {
                    showAlert('error', 'Failed to parse JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function loadIntegrationData(data) {
            integrationData = data;
            canvasNodes = [];

            // Create system nodes
            let systemX = 100;
            let systemY = 100;
            Object.keys(data.systems || {}).forEach((sysId, idx) => {
                const system = data.systems[sysId];
                canvasNodes.push({
                    id: sysId,
                    type: 'system',
                    subtype: system.type,
                    data: system,
                    x: systemX + (idx % 3) * 300,
                    y: systemY + Math.floor(idx / 3) * 250
                });
            });

            // Create integration nodes
            let integrationY = 400;
            (data.integrations || []).forEach((integration, idx) => {
                canvasNodes.push({
                    id: integration.id,
                    type: 'integration',
                    pattern: integration.pattern,
                    data: integration,
                    x: 200 + idx * 350,
                    y: integrationY
                });
            });

            renderCanvas();
            clearEmptyState();
            fitToView();
            saveHistory();
        }

        function loadExample(exampleType) {
            const examples = {
                'rest-api': 'examples/rest-api-integration.json',
                'kafka': 'examples/kafka-event-stream.json',
                'file-transfer': 'examples/file-transfer-batch.json'
            };

            const examplePath = examples[exampleType];
            if (examplePath) {
                fetch(examplePath)
                    .then(response => response.json())
                    .then(data => {
                        loadIntegrationData(data);
                        showAlert('success', 'Example loaded successfully!');
                    })
                    .catch(error => {
                        showAlert('error', 'Failed to load example: ' + error.message);
                    });
            }
        }

        // ============ Templates ============
        function openTemplates() {
            document.getElementById('templateModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function loadTemplate(templateType) {
            // Template data (same as before, abbreviated for space)
            const templates = {
                'rest-api': {
                    version: "1.0.0",
                    info: {
                        title: "REST API Integration Template",
                        version: "1.0.0",
                        description: "Template for REST API integration",
                        tags: ["rest-api", "template"]
                    },
                    systems: {
                        "source-api": {
                            name: "Source API",
                            type: "external",
                            description: "Source REST API",
                            environment: "production",
                            owner: "",
                            version: ""
                        },
                        "target-api": {
                            name: "Target API",
                            type: "application",
                            description: "Target REST API",
                            environment: "production",
                            owner: "",
                            version: ""
                        }
                    },
                    integrations: [{
                        id: "rest-integration-1",
                        name: "REST API Integration",
                        description: "Synchronous REST API data exchange",
                        pattern: "rest-api",
                        source: {
                            system: "source-api",
                            protocol: "https",
                            format: "json"
                        },
                        target: {
                            system: "target-api",
                            protocol: "https",
                            format: "json"
                        },
                        trigger: {
                            type: "webhook"
                        },
                        transformation: {
                            type: "mapping",
                            mapping: {}
                        },
                        errorHandling: {
                            retry: {
                                maxAttempts: 3,
                                backoff: "exponential",
                                delay: "2s"
                            }
                        },
                        metadata: {
                            owner: "",
                            tags: ["rest", "template"]
                        },
                        config: {
                            method: "POST",
                            path: "/api/endpoint",
                            timeout: "30s"
                        }
                    }],
                    components: {
                        schemas: {},
                        securitySchemes: {}
                    }
                }
                // Add other templates here (abbreviated for space)
            };

            const template = templates[templateType];
            if (template) {
                loadIntegrationData(template);
                closeModal('templateModal');
                showAlert('success', `${templateType} template loaded successfully!`);
            }
        }

        // ============ Validation ============
        function validateDesign() {
            // Redirect to new comprehensive validation
            showValidationResults();
        }

        // ============ Utility Functions ============
        function clearEmptyState() {
            const emptyState = document.querySelector('.canvas-inner .empty-state');
            if (emptyState) {
                emptyState.remove();
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear everything? This cannot be undone.')) {
                integrationData = {
                    version: "1.0.0",
                    info: {
                        title: "New Integration",
                        version: "1.0.0",
                        description: "",
                        tags: []
                    },
                    systems: {},
                    integrations: [],
                    components: {
                        schemas: {},
                        securitySchemes: {}
                    }
                };
                canvasNodes = [];
                selectedNode = null;
                history = [];
                historyIndex = -1;

                // Clear nodes
                const canvasInner = document.getElementById('canvasInner');
                canvasInner.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé®</div>
                        <h3>Start Building Your Integration</h3>
                        <p>Drag systems and integration patterns from the left panel</p>
                        <p style="margin-top: 0.5rem;"><strong>Create Edges:</strong> Click & drag from any purple connection point</p>
                        <p style="margin-top: 0.25rem;">Each node has 4 connection points (‚¨ÜÔ∏è‚û°Ô∏è‚¨áÔ∏è‚¨ÖÔ∏è)</p>
                        <p style="margin-top: 0.5rem;">Or load an example to get started quickly</p>
                    </div>
                `;

                // Clear connections/edges
                const svg = document.getElementById('connectionsSvg');
                svg.querySelectorAll('path:not(.creating), line, text, rect').forEach(el => el.remove());

                deselectAll();
                resetZoom();
                saveHistory();
                showAlert('info', 'Canvas cleared');
            }
        }

        function newIntegration() {
            showAlert('info', 'Drag an integration pattern from the left panel, or drag between two systems to connect them!');
        }

        function toggleHelp() {
            const help = document.getElementById('helpOverlay');
            help.classList.toggle('active');
        }

        function showAlert(type, message) {
            const alertClass = `alert-${type}`;
            const alertDiv = document.createElement('div');
            alertDiv.innerHTML = `
                <div class="alert ${alertClass}" style="position: fixed; top: 100px; right: 20px; z-index: 1001; max-width: 400px; white-space: pre-line;">
                    ${message}
                </div>
            `;

            document.body.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // ============ PHASE 1: Core UX Improvements ============

        // === Palette Search & Filter ===
        function filterPalette(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            const items = document.querySelectorAll('.palette-item');

            items.forEach(item => {
                if (!term) {
                    item.classList.remove('search-hidden', 'search-match');
                    return;
                }

                const searchTerms = item.getAttribute('data-search-terms') || '';
                const title = item.querySelector('.palette-label-title')?.textContent || '';
                const desc = item.querySelector('.palette-label-desc')?.textContent || '';
                const searchableText = `${searchTerms} ${title} ${desc}`.toLowerCase();

                if (searchableText.includes(term)) {
                    item.classList.remove('search-hidden');
                    item.classList.add('search-match');
                } else {
                    item.classList.add('search-hidden');
                    item.classList.remove('search-match');
                }
            });
        }

        function clearPaletteSearch() {
            document.getElementById('paletteSearch').value = '';
            filterPalette('');
        }

        function toggleSection(sectionId) {
            const content = document.getElementById(`${sectionId}Content`);
            const header = event.currentTarget;

            if (content.style.display === 'none') {
                content.style.display = 'block';
                header.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                header.classList.add('collapsed');
            }
        }

        // === Multi-Select System ===
        let selectedNodes = new Set();

        function selectAll() {
            selectedNodes.clear();
            canvasNodes.forEach(node => selectedNodes.add(node.id));
            updateSelectionUI();
            showAlert('info', `Selected ${canvasNodes.length} items`);
        }

        function updateSelectionUI() {
            document.querySelectorAll('.system-node, .integration-node').forEach(nodeEl => {
                const nodeId = nodeEl.getAttribute('data-node-id');
                if (selectedNodes.has(nodeId)) {
                    nodeEl.classList.add(selectedNodes.size === 1 ? 'selected' : 'multi-selected');
                } else {
                    nodeEl.classList.remove('selected', 'multi-selected');
                }
            });

            const bulkBtn = document.getElementById('bulkActions');
            if (selectedNodes.size > 1) {
                bulkBtn.style.display = 'block';
                bulkBtn.textContent = `Actions (${selectedNodes.size}) ‚ñº`;
            } else {
                bulkBtn.style.display = 'none';
            }

            updateSelectionBadge();
        }

        function updateSelectionBadge() {
            let badge = document.getElementById('selectionBadge');

            if (selectedNodes.size > 1) {
                if (!badge) {
                    badge = document.createElement('div');
                    badge.id = 'selectionBadge';
                    badge.className = 'selection-badge';
                    document.body.appendChild(badge);
                }
                badge.innerHTML = `<span>${selectedNodes.size} selected</span>
                    <button onclick="deselectAll()" style="background: rgba(255,255,255,0.2); border: none; border-radius: 50%; width: 1.5rem; height: 1.5rem; cursor: pointer; color: white;">‚úï</button>`;
            } else if (badge) {
                badge.remove();
            }
        }

        // Override deselectAll to work with multi-select
        const originalDeselectAll = deselectAll;
        deselectAll = function() {
            selectedNodes.clear();
            updateSelectionUI();
            originalDeselectAll();
        };

        // === Bulk Operations ===
        function showBulkActionsMenu() {
            const menu = document.getElementById('bulkActionsMenu');
            const btn = document.getElementById('bulkActions');
            const rect = btn.getBoundingClientRect();

            menu.style.display = 'block';
            menu.style.left = rect.left + 'px';
            menu.style.top = (rect.bottom + 5) + 'px';

            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target) && e.target !== btn) {
                        menu.style.display = 'none';
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        function bulkAlign(direction) {
            if (selectedNodes.size < 2) return;

            const nodes = Array.from(selectedNodes).map(id => canvasNodes.find(n => n.id === id));

            if (direction === 'left') {
                const minX = Math.min(...nodes.map(n => n.x));
                nodes.forEach(node => node.x = minX);
            } else if (direction === 'right') {
                const maxX = Math.max(...nodes.map(n => n.x + 200));
                nodes.forEach(node => node.x = maxX - 200);
            } else if (direction === 'top') {
                const minY = Math.min(...nodes.map(n => n.y));
                nodes.forEach(node => node.y = minY);
            } else if (direction === 'bottom') {
                const maxY = Math.max(...nodes.map(n => n.y + 150));
                nodes.forEach(node => node.y = maxY - 150);
            }

            renderCanvas();
            saveHistory();
            showAlert('success', `Aligned ${nodes.length} items to ${direction}`);
            document.getElementById('bulkActionsMenu').style.display = 'none';
        }

        function bulkDistribute(direction) {
            if (selectedNodes.size < 3) {
                showAlert('warning', 'Need at least 3 items to distribute');
                return;
            }

            const nodes = Array.from(selectedNodes)
                .map(id => canvasNodes.find(n => n.id === id))
                .sort((a, b) => direction === 'horizontal' ? a.x - b.x : a.y - b.y);

            if (direction === 'horizontal') {
                const minX = nodes[0].x;
                const maxX = nodes[nodes.length - 1].x;
                const spacing = (maxX - minX) / (nodes.length - 1);
                nodes.forEach((node, i) => {
                    if (i > 0 && i < nodes.length - 1) node.x = minX + spacing * i;
                });
            } else {
                const minY = nodes[0].y;
                const maxY = nodes[nodes.length - 1].y;
                const spacing = (maxY - minY) / (nodes.length - 1);
                nodes.forEach((node, i) => {
                    if (i > 0 && i < nodes.length - 1) node.y = minY + spacing * i;
                });
            }

            renderCanvas();
            saveHistory();
            showAlert('success', `Distributed ${nodes.length} items`);
            document.getElementById('bulkActionsMenu').style.display = 'none';
        }

        function bulkDuplicate() {
            if (selectedNodes.size === 0) return;

            const newNodes = [];
            selectedNodes.forEach(nodeId => {
                const node = canvasNodes.find(n => n.id === nodeId);
                if (!node) return;

                const newId = 'node-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                const newNode = {
                    ...JSON.parse(JSON.stringify(node)),
                    id: newId,
                    x: node.x + 50,
                    y: node.y + 50,
                    data: { ...node.data, name: node.data.name + ' (Copy)' }
                };

                canvasNodes.push(newNode);
                newNodes.push(newId);

                if (node.type === 'system') {
                    integrationData.systems[newId] = newNode.data;
                } else {
                    integrationData.integrations.push({ ...newNode.data, id: newId });
                }
            });

            selectedNodes.clear();
            newNodes.forEach(id => selectedNodes.add(id));
            renderCanvas();
            updateSelectionUI();
            saveHistory();
            showAlert('success', `Duplicated ${newNodes.length} items`);
            document.getElementById('bulkActionsMenu').style.display = 'none';
        }

        function bulkDelete() {
            if (selectedNodes.size === 0) return;

            const count = selectedNodes.size;
            if (!confirm(`Delete ${count} selected item${count > 1 ? 's' : ''}?`)) return;

            selectedNodes.forEach(nodeId => {
                const node = canvasNodes.find(n => n.id === nodeId);
                if (!node) return;

                if (node.type === 'system') {
                    delete integrationData.systems[nodeId];
                    integrationData.integrations.forEach(i => {
                        if (i.source.system === nodeId) i.source.system = '';
                        if (i.target.system === nodeId) i.target.system = '';
                    });
                } else {
                    integrationData.integrations = integrationData.integrations.filter(i => i.id !== nodeId);
                }
            });

            canvasNodes = canvasNodes.filter(n => !selectedNodes.has(n.id));
            selectedNodes.clear();
            renderCanvas();
            updateSelectionUI();
            saveHistory();
            showAlert('success', `Deleted ${count} items`);
            document.getElementById('bulkActionsMenu').style.display = 'none';
        }

        // === Grid & Alignment Guides ===
        let gridSettings = {
            enabled: false,
            snapEnabled: false,
            guidesEnabled: true,
            gridSize: 20
        };

        function toggleGrid() {
            gridSettings.enabled = !gridSettings.enabled;
            const canvas = document.getElementById('canvas');
            const btn = document.getElementById('gridToggle');

            if (gridSettings.enabled) {
                canvas.classList.add('show-grid');
                btn.classList.add('active');
            } else {
                canvas.classList.remove('show-grid');
                btn.classList.remove('active');
            }
        }

        function toggleSnapToGrid() {
            gridSettings.snapEnabled = !gridSettings.snapEnabled;
            const btn = document.getElementById('snapToggle');
            btn.classList.toggle('active', gridSettings.snapEnabled);
            showAlert('info', gridSettings.snapEnabled ? 'Snap to grid enabled' : 'Snap to grid disabled');
        }

        function toggleAlignmentGuides() {
            gridSettings.guidesEnabled = !gridSettings.guidesEnabled;
            const btn = document.getElementById('guidesToggle');
            btn.classList.toggle('active', gridSettings.guidesEnabled);
        }

        function snapToGrid(value) {
            if (!gridSettings.snapEnabled) return value;
            return Math.round(value / gridSettings.gridSize) * gridSettings.gridSize;
        }

        // === Mini-Map ===
        let miniMapState = { enabled: true };

        function toggleMiniMap() {
            miniMapState.enabled = !miniMapState.enabled;
            document.getElementById('miniMap').classList.toggle('hidden', !miniMapState.enabled);
        }

        function renderMiniMap() {
            if (!miniMapState.enabled || canvasNodes.length === 0) return;

            const container = document.getElementById('miniMapCanvas');
            container.innerHTML = '';

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            canvasNodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 200);
                maxY = Math.max(maxY, node.y + 150);
            });

            const scale = Math.min(container.clientWidth / (maxX - minX), container.clientHeight / (maxY - minY), 1);

            canvasNodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.className = `mini-map-node ${node.type}`;
                nodeEl.style.left = ((node.x - minX) * scale) + 'px';
                nodeEl.style.top = ((node.y - minY) * scale) + 'px';
                nodeEl.style.width = (200 * scale) + 'px';
                nodeEl.style.height = (150 * scale) + 'px';
                container.appendChild(nodeEl);
            });
        }

        // Update mini-map when canvas changes
        const originalRenderCanvas = renderCanvas;
        renderCanvas = function() {
            originalRenderCanvas();
            setTimeout(renderMiniMap, 100);
        };

        // === Enhanced Keyboard Shortcuts ===
        document.addEventListener('keydown', (e) => {
            if (e.target.matches('input, textarea, select')) return;

            const ctrl = e.ctrlKey || e.metaKey;

            // Ctrl+A: Select all
            if (ctrl && e.key === 'a') {
                e.preventDefault();
                selectAll();
            }

            // Escape: Deselect
            if (e.key === 'Escape') {
                deselectAll();
            }

            // Delete/Backspace: Delete selected
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodes.size > 0) {
                e.preventDefault();
                bulkDelete();
            }

            // Ctrl+D: Duplicate
            if (ctrl && e.key === 'd' && selectedNodes.size > 0) {
                e.preventDefault();
                bulkDuplicate();
            }

            // Ctrl+G: Toggle grid
            if (ctrl && e.key === 'g') {
                e.preventDefault();
                toggleGrid();
            }

            // Ctrl+Arrow: Bulk align
            if (ctrl && selectedNodes.size > 1) {
                if (e.key === 'ArrowLeft') { e.preventDefault(); bulkAlign('left'); }
                if (e.key === 'ArrowRight') { e.preventDefault(); bulkAlign('right'); }
                if (e.key === 'ArrowUp') { e.preventDefault(); bulkAlign('top'); }
                if (e.key === 'ArrowDown') { e.preventDefault(); bulkAlign('bottom'); }
            }

            // Ctrl+K: Focus search
            if (ctrl && e.key === 'k') {
                e.preventDefault();
                document.getElementById('paletteSearch')?.focus();
            }
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            renderMiniMap();
        });
    </script>
</body>
</html>
